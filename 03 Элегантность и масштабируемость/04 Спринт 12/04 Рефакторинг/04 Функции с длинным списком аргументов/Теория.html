<!DOCTYPE html>
<html>
<head>
  <title>Функции с длинным списком аргументов</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta charset="utf-8">
<style>body{font-family:Helvetica,arial,sans-serif;font-size:14px;line-height:1.6;background-color:#fff;padding:30px;color:#333;max-width:1140px;margin:0 auto}body > :first-child{margin-top:0!important}body > :last-child{margin-bottom:0!important}a{color:#4183C4;text-decoration:none}a.absent{color:#c00}a.anchor{display:block;padding-left:30px;margin-left:-30px;cursor:pointer;position:absolute;top:0;left:0;bottom:0}h1,h2,h3,h4,h5,h6{margin:20px 0 10px;padding:0;font-weight:700;-webkit-font-smoothing:antialiased;cursor:text;position:relative}h2:first-child,h1:first-child,h1:first-child + h2,h3:first-child,h4:first-child,h5:first-child,h6:first-child{margin-top:0;padding-top:0}h1:hover a.anchor,h2:hover a.anchor,h3:hover a.anchor,h4:hover a.anchor,h5:hover a.anchor,h6:hover a.anchor{text-decoration:none}h1 tt,h1 code{font-size:inherit}h2 tt,h2 code{font-size:inherit}h3 tt,h3 code{font-size:inherit}h4 tt,h4 code{font-size:inherit}h5 tt,h5 code{font-size:inherit}h6 tt,h6 code{font-size:inherit}h1{font-size:28px;color:#000}h2{font-size:24px;border-bottom:1px solid #ccc;color:#000}h3{font-size:18px}h4{font-size:16px}h5{font-size:14px}h6{color:#777;font-size:14px}p,blockquote,ul,ol,dl,li,table,pre{margin:15px 0}hr {padding:0;margin-bottom:-8px;height:1px;border:none;background:black}body > h2:first-child{margin-top:0;padding-top:0}body > h1:first-child{margin-top:0;padding-top:0}body > h1:first-child + h2{margin-top:0;padding-top:0}body > h3:first-child,body > h4:first-child,body > h5:first-child,body > h6:first-child{margin-top:0;padding-top:0}a:first-child h1,a:first-child h2,a:first-child h3,a:first-child h4,a:first-child h5,a:first-child h6{margin-top:0;padding-top:0}h1 p,h2 p,h3 p,h4 p,h5 p,h6 p{margin-top:0}li p.first{display:inline-block}ul,ol{padding-left:30px}ul :first-child,ol :first-child{margin-top:0}ul :last-child,ol :last-child{margin-bottom:0}dl{padding:0}dl dt{font-size:14px;font-weight:700;font-style:italic;padding:0;margin:15px 0 5px}dl dt:first-child{padding:0}dl dt > :first-child{margin-top:0}dl dt > :last-child{margin-bottom:0}dl dd{margin:0 0 15px;padding:0 15px}dl dd > :first-child{margin-top:0}dl dd > :last-child{margin-bottom:0}blockquote{border-left:4px solid #ddd;padding:0 15px;color:#777}blockquote > :first-child{margin-top:0}blockquote > :last-child{margin-bottom:0}table{padding:0}table tr{border-top:1px solid #ccc;background-color:#fff;margin:0;padding:0}table tr:nth-child(2n){background-color:#f8f8f8}table tr th{font-weight:700;border:1px solid #ccc;text-align:left;margin:0;padding:6px 13px}table tr td{border:1px solid #ccc;text-align:left;margin:0;padding:6px 13px}table tr th :first-child,table tr td :first-child{margin-top:0}table tr th :last-child,table tr td :last-child{margin-bottom:0}img{max-width:100%;display:block}span.frame{display:block;overflow:hidden}span.frame > span{border:1px solid #ddd;display:block;float:left;overflow:hidden;margin:13px 0 0;padding:7px;width:auto}span.frame span img{display:block;float:left}span.frame span span{clear:both;color:#333;display:block;padding:5px 0 0}span.align-center{display:block;overflow:hidden;clear:both}span.align-center > span{display:block;overflow:hidden;margin:13px auto 0;text-align:center}span.align-center span img{margin:0 auto;text-align:center}span.align-right{display:block;overflow:hidden;clear:both}span.align-right > span{display:block;overflow:hidden;margin:13px 0 0;text-align:right}span.align-right span img{margin:0;text-align:right}span.float-left{display:block;margin-right:13px;overflow:hidden;float:left}span.float-left span{margin:13px 0 0}span.float-right{display:block;margin-left:13px;overflow:hidden;float:right}span.float-right > span{display:block;overflow:hidden;margin:13px auto 0;text-align:right}code,tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px}pre code{margin:0;padding:0;white-space:pre;border:none;background:transparent}.highlight pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre code,pre tt{background-color:transparent;border:none}.slasher{color:#000000}</style></head>
<body>

<h1>Функции с длинным списком аргументов</h1>

<p>Вы подробно изучили проблемы конструкторов с большим количеством параметров и способы решения этих проблем. Теми же недостатками могут обладать любые функции и методы.</p>

<p>Проблемы, присущие функциям с большим количеством параметров:</p>

<ol>
<li>Когда параметров много, функцию трудно понимать и тестировать.</li>
<li>Когда целочисленных и булевых параметров много, они приводят к ошибкам в месте вызова и необходимости упоминать название аргумента рядом с его значением.</li>
</ol>

<p>В качестве примера рассмотрим гипотетическую функцию парсинга (разбора) поискового запроса:</p>

<pre><code class="language-cpp">Query ParseQuery(string_view text, 
                 int country_id, 
                 int max_word_count, 
                 int max_word_length, 
                 int max_form_count_per_word,
                 bool allow_minus_words, 
                 bool keep_stop_words, 
                 bool case_sensitive);
</code></pre>

<p>Pазъясним смысл параметров:</p>

<ul>
<li><code>text</code> — сам поисковый запрос;</li>
<li><code>country_id</code> — id страны, из которой он пришёл;</li>
<li><code>max_word_count</code> — максимальное количество слов, которое будет учтено;</li>
<li><code>max_word_length</code> — максимальное количество букв слова, которое будет учтено;</li>
<li><code>max_form_count_per_word</code> — максимальное количество словоформ, генерируемых на одно слово;</li>
<li><code>allow_minus_words</code> — обрабатывать ли минус-слова;</li>
<li><code>keep_stop_words</code> — считать ли стоп-слова полноценными словами;</li>
<li><code>case_sensitive</code> — учитывать ли регистр слов.</li>
</ul>

<p>Вызов этой функции может доставить серьёзный дискомфорт человеку, читающему код:</p>

<pre><code class="language-cpp">const Query query = ParseQuery(text, 225, 7, 23, 20, true, false, false);
</code></pre>

<p>Аргументы можно снабжать комментариями, но это не защитит от ошибок:</p>

<pre><code class="language-cpp">const Query query = ParseQuery(text, /* country_id */ 7,
                               /* max_word_count */ 225,
                               /* max_word_length */ 23,
                               /* max_form_count_per_word */ 20,
                               /* allow_minus_words */ true,
                               /* keep_stop_words */ false,
                               /* case_sensitive */ false);
</code></pre>

<h3>Структура для параметров</h3>

<p>Решение, известное из предыдущего урока, — объединение параметров функции в структуру с Set-методами. Громоздко, но безотказно.</p>

<p>В случае функции <code>ParseQuery</code> можно было бы вынести в <code>ParsingParams</code> последние шесть параметров:</p>

<pre><code class="language-cpp">const Query query = ParseQuery( text, 225,
                                ParsingParams().
                                SetMaxWordCount(7).
                                SetMaxWordLength(23).
                                SetMaxFormCountPerWord(20).
                                SetAllowMinusWords(true));
</code></pre>

<p>Параметрам <code>keep_stop_words</code> и <code>case_sensitive</code> можно присвоить значения по умолчанию, которые они получат при отсутствии вызова соответствующих Set-методов. Это позволит не указывать их при инициализации <code>ParsingParams</code>.</p>

<p>Вот так будет выглядеть вызов функции при использовании designated initializers. Зададим все параметры для наглядности:</p>

<pre><code class="language-cpp">const Query query = ParseQuery(text, 225,
                               {.max_word_count = 7,
                                .max_word_length = 23,
                                .max_form_count_per_word = 20,
                                .allow_minus_words = true,
                                .keep_stop_words = false,
                                .case_sensitive = false});
</code></pre>

<h3>Превращение функции в метод класса</h3>

<p>Если требуется распарсить поток запросов с одинаковыми настройками, стоит рассмотреть вариант создания класса <code>QueryParser</code> с инициализацией по одной из рассмотренных выше методологий и методом <code>Parse</code>:</p>

<pre><code class="language-cpp">class QueryParser {
public:
    QueryParser(const ParsingParams&amp; params);
    Query Parse(string_view text, int country_id);
};

// ...

QueryParser parser(ParsingParams{.max_word_count = 7,
                                 .max_word_length = 23,
                                 .max_form_count_per_word = 20,
                                 .allow_minus_words = true,
                                 .keep_stop_words = false,
                                 .case_sensitive = false});

// ...

const Query query = parser.Parse(text, 225);
</code></pre>

<p>Все предыдущие идеи во многом касались структурирования параметров функции. Теперь разберём несложные способы усовершенствовать работу с булевыми и числовыми параметрами.</p>

<h3>Использование enum вместо bool</h3>

<p>Для некоторых <code>bool</code>-параметров может быть оправдан переход на <code>enum</code>. Например, в будущем вы можете захотеть добавить ещё один режим учёта стоп-слов: учитывать их только в том случае, если перед ними идёт символ +. Тогда можно добавить <code>enum</code>-тип <code>StopWordsMode</code> «на вырост», тем самым повысив читаемость вызова функции и избежав шанса перепутать параметры с другими аргументами типа <code>int</code> и <code>bool</code>:</p>

<pre><code class="language-cpp">enum class StopWordsMode {
    IGNORE,
    KEEP,
    // в будущем этот класс можно будет расширять
};

Query ParseQuery(string_view text, int country_id, int max_word_count, int max_word_length, int max_form_count_per_word,
                 bool allow_minus_words, StopWordsMode stop_words_mode, bool case_sensitive);

// ...

const Query query = ParseQuery(text, 225, 7, 23, 20, true, StopWordsMode::IGNORE, false);
</code></pre>

<h3>Объединение булевых параметров в маску</h3>

<p>Беззнаковые числовые типы часто используются как хранилище битов: например, число типа uint64_t позволяет сохранить 64 булевых значения. Поэтому булевы флаги можно объединить в один <code>enum ParsingFlag</code> и собрать из подручных средств такую конструкцию:</p>

<pre><code class="language-cpp">enum class ParsingFlag {
    // значения, являющиеся степенями двойки,
    // позволяют работать с масками без дополнительных
    // преобразований вида 1 &lt;&lt; value
    ALLOW_MINUS_WORDS = 1 &lt;&lt; 0,  // 001
    KEEP_STOP_WORDS = 1 &lt;&lt; 1,    // 010
    CASE_SENSITIVE = 1 &lt;&lt; 2      // 100
};

using ParsingFlags = uint64_t;

Query ParseQuery(string_view text, int country_id, int max_word_count, int max_word_length, int max_form_count_per_word,
                 ParsingFlags flags) {
    // ...
    if (flags &amp; static_cast&lt;ParsingFlags&gt;(ParsingFlag::KEEP_STOP_WORDS)) {
        // обработка запроса с учётом флага KEEP_STOP_WORDS
    }
    // ...
}

// ...

const Query query = ParseQuery(text, 225, 7, 23, 20,
                               static_cast&lt;ParsingFlags&gt;(ParsingFlag::ALLOW_MINUS_WORDS)
                               | static_cast&lt;ParsingFlags&gt;(ParsingFlag::KEEP_STOP_WORDS));
                               // выключенные флаги не указываются в списке
</code></pre>

<p>Довольно неудобно писать всюду <code>static_cast</code>, поэтому можно создать простой шаблон <code>Flags</code> и определить для <code>Flags&lt;ParsingFlag&gt;</code> и <code>ParsingFlag</code> операторы <code>&amp;</code> и <code>|</code> так, чтобы следующий код работал, как предыдущий:</p>

<pre><code class="language-cpp">enum class ParsingFlag { 
    ALLOW_MINUS_WORDS = 1 &lt;&lt; 0, 
    KEEP_STOP_WORDS = 1 &lt;&lt; 1, 
    CASE_SENSITIVE = 1 &lt;&lt; 2 
};

using ParsingFlags = Flags&lt;ParsingFlag&gt;;

Query ParseQuery(string_view text, int country_id, int max_word_count, int max_word_length, int max_form_count_per_word,
                 ParsingFlags flags) {
    // ...
    if (flags &amp; ParsingFlag::KEEP_STOP_WORDS) {
        // обработка запроса с учётом флага KEEP_STOP_WORDS
    }
    // ...
}

// ...

const Query query = ParseQuery(text, 225, 7, 23, 20, 
                               ParsingFlag::ALLOW_MINUS_WORDS | ParsingFlag::KEEP_STOP_WORDS);
</code></pre>

<h3>Отдельные типы для числовых параметров</h3>

<p>Наконец, посмотрим, что сделать с числовыми параметрами функций для повышения прозрачности и безопасности вызовов.</p>

<p>Безопасности не будет без типизации. Поэтому определим для каждого числового параметра свой тип с explicit-конструктором:</p>

<pre><code class="language-cpp">struct CountryId {
    int value;
    explicit CountryId(int v)
        : value(v) 
    {
    }
};

struct MaxWordCount {
    int value;
    explicit MaxWordCount(int v)
        : value(v) 
    {
    }
};

struct MaxWordLength {
    int value;
    explicit MaxWordLength(int v)
        : value(v) 
    {
    }
};

struct MaxFormCountPerWord {
    int value;
    explicit MaxFormCountPerWord(int v)
        : value(v) 
    {
    }
};

Query ParseQuery(string_view text, 
                 CountryId country_id, 
                 MaxWordCount max_word_count, 
                 MaxWordLength max_word_length,
                 MaxFormCountPerWord max_form_count_per_word, 
                 bool allow_minus_words, 
                 bool keep_stop_words,
                 bool case_sensitive);

// ...

const Query query = ParseQuery(text, CountryId(225), 
                               MaxWordCount(7), 
                               MaxWordLength(23), 
                               MaxFormCountPerWord(20), 
                               true, false, false);
</code></pre>

<p>То же можно проделать и для булевых параметров.</p>

<p>Определение каждой такой структуры довольно однотипно, поэтому напрашивается макрос <code>DECLARE_INT_PARAM</code>:</p>

<pre><code class="language-cpp">#define DECLARE_INT_PARAM(Name) \
    struct Name {               \
        int value;              \
        explicit Name(int v)    \
            : value(v) {        \
        }                       \
    }

DECLARE_INT_PARAM(CountryId);
DECLARE_INT_PARAM(MaxWordCount);
DECLARE_INT_PARAM(MaxWordLength);
DECLARE_INT_PARAM(MaxFormCountPerWord);
</code></pre>

<p>Можно доработать этот макрос так, чтобы разрешить подобным типам автоматически приводиться к <code>int</code>. Вы избавите авторов функции от необходимости постоянно обращаться к полю <code>value</code>:</p>

<pre><code class="language-cpp">#define DECLARE_INT_PARAM(Name) \
    struct Name {               \
        int value;              \
        explicit Name(int v)    \
            : value(v) {        \
        }                       \
        operator int() const {  \
            return value;       \
        }                       \
    }
</code></pre>

<p>Ещё один способ создания подобных типов, принятый в том числе и в стандартной библиотеке, — определение специальных суффиксов. Они позволяют писать так:</p>

<pre><code class="language-cpp">const Query query = ParseQuery(text, CountryId(225),
                               7_words, 23_letters, 20_forms,
                               true, false, false);
</code></pre>

<p>Определение таких суффиксов возможно благодаря строковым литералам, о которых уже шла речь в спринте 11. <code>operator&quot;&quot;</code> решает эту задачу так:</p>

<pre><code class="language-cpp">auto operator&quot;&quot;_words(unsigned long long value) {
    return MaxWordCount(value);
}

auto operator&quot;&quot;_letters(unsigned long long value) {
    return MaxWordLength(value);
}

auto operator&quot;&quot;_forms(unsigned long long value) {
    return MaxFormCountPerWord(value);
}
</code></pre>

<p>Числовой параметр такого оператора обязан иметь тип <code>unsigned long long</code>.</p>

<p>По сути выражение <code>7_words</code> эквивалентно вызову <code>operator&quot;&quot;_words(7)</code> и, в конечном счёте, <code>MaxWordCount(7)</code>.</p>

<h3>Итоги</h3>

<p>Есть несколько способов борьбы с громоздкостью и запутанностью списка параметров функции:</p>

<ol>
<li>Сгруппировать параметры в структуры.</li>
<li>Сделать функцию методом класса, унеся глобальный контекст из параметров функции в поля класса.</li>
<li>Использовать <code>enum</code> для булевых параметров: свой для каждого или один общий — с маской.</li>
<li>Определять отдельные типы для числовых параметров, снабжая их explicit-конструкторами или другими способами явного создания при вызове функции.</li>
</ol>

</body>
</html>
