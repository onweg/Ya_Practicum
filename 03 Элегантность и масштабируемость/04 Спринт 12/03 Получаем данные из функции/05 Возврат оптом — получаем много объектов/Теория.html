<!DOCTYPE html>
<html>
<head>
  <title>Возврат оптом — получаем много объектов</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta charset="utf-8">
<style>body{font-family:Helvetica,arial,sans-serif;font-size:14px;line-height:1.6;background-color:#fff;padding:30px;color:#333;max-width:1140px;margin:0 auto}body > :first-child{margin-top:0!important}body > :last-child{margin-bottom:0!important}a{color:#4183C4;text-decoration:none}a.absent{color:#c00}a.anchor{display:block;padding-left:30px;margin-left:-30px;cursor:pointer;position:absolute;top:0;left:0;bottom:0}h1,h2,h3,h4,h5,h6{margin:20px 0 10px;padding:0;font-weight:700;-webkit-font-smoothing:antialiased;cursor:text;position:relative}h2:first-child,h1:first-child,h1:first-child + h2,h3:first-child,h4:first-child,h5:first-child,h6:first-child{margin-top:0;padding-top:0}h1:hover a.anchor,h2:hover a.anchor,h3:hover a.anchor,h4:hover a.anchor,h5:hover a.anchor,h6:hover a.anchor{text-decoration:none}h1 tt,h1 code{font-size:inherit}h2 tt,h2 code{font-size:inherit}h3 tt,h3 code{font-size:inherit}h4 tt,h4 code{font-size:inherit}h5 tt,h5 code{font-size:inherit}h6 tt,h6 code{font-size:inherit}h1{font-size:28px;color:#000}h2{font-size:24px;border-bottom:1px solid #ccc;color:#000}h3{font-size:18px}h4{font-size:16px}h5{font-size:14px}h6{color:#777;font-size:14px}p,blockquote,ul,ol,dl,li,table,pre{margin:15px 0}hr {padding:0;margin-bottom:-8px;height:1px;border:none;background:black}body > h2:first-child{margin-top:0;padding-top:0}body > h1:first-child{margin-top:0;padding-top:0}body > h1:first-child + h2{margin-top:0;padding-top:0}body > h3:first-child,body > h4:first-child,body > h5:first-child,body > h6:first-child{margin-top:0;padding-top:0}a:first-child h1,a:first-child h2,a:first-child h3,a:first-child h4,a:first-child h5,a:first-child h6{margin-top:0;padding-top:0}h1 p,h2 p,h3 p,h4 p,h5 p,h6 p{margin-top:0}li p.first{display:inline-block}ul,ol{padding-left:30px}ul :first-child,ol :first-child{margin-top:0}ul :last-child,ol :last-child{margin-bottom:0}dl{padding:0}dl dt{font-size:14px;font-weight:700;font-style:italic;padding:0;margin:15px 0 5px}dl dt:first-child{padding:0}dl dt > :first-child{margin-top:0}dl dt > :last-child{margin-bottom:0}dl dd{margin:0 0 15px;padding:0 15px}dl dd > :first-child{margin-top:0}dl dd > :last-child{margin-bottom:0}blockquote{border-left:4px solid #ddd;padding:0 15px;color:#777}blockquote > :first-child{margin-top:0}blockquote > :last-child{margin-bottom:0}table{padding:0}table tr{border-top:1px solid #ccc;background-color:#fff;margin:0;padding:0}table tr:nth-child(2n){background-color:#f8f8f8}table tr th{font-weight:700;border:1px solid #ccc;text-align:left;margin:0;padding:6px 13px}table tr td{border:1px solid #ccc;text-align:left;margin:0;padding:6px 13px}table tr th :first-child,table tr td :first-child{margin-top:0}table tr th :last-child,table tr td :last-child{margin-bottom:0}img{max-width:100%;display:block}span.frame{display:block;overflow:hidden}span.frame > span{border:1px solid #ddd;display:block;float:left;overflow:hidden;margin:13px 0 0;padding:7px;width:auto}span.frame span img{display:block;float:left}span.frame span span{clear:both;color:#333;display:block;padding:5px 0 0}span.align-center{display:block;overflow:hidden;clear:both}span.align-center > span{display:block;overflow:hidden;margin:13px auto 0;text-align:center}span.align-center span img{margin:0 auto;text-align:center}span.align-right{display:block;overflow:hidden;clear:both}span.align-right > span{display:block;overflow:hidden;margin:13px 0 0;text-align:right}span.align-right span img{margin:0;text-align:right}span.float-left{display:block;margin-right:13px;overflow:hidden;float:left}span.float-left span{margin:13px 0 0}span.float-right{display:block;margin-left:13px;overflow:hidden;float:right}span.float-right > span{display:block;overflow:hidden;margin:13px auto 0;text-align:right}code,tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px}pre code{margin:0;padding:0;white-space:pre;border:none;background:transparent}.highlight pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre code,pre tt{background-color:transparent;border:none}.slasher{color:#000000}</style></head>
<body>

<h1>Возврат оптом — получаем много объектов</h1>

<p>В прошлой теме вы узнали, как передать набор объектов в функцию. Варианты были такие:</p>

<ul>
<li>пара итераторов,</li>
<li>контейнер,</li>
<li>количество с указателем либо итератором,</li>
<li><code>span</code>.</li>
</ul>

<p>Для возврата из функции эти способы также годятся, но применять их надо с умом. И первое, что нужно решить, — передаёт ли функция владение набором объектов или оставляет его себе.</p>

<h3>Возврат контейнера</h3>

<p>Если функция вызывалась для того, чтобы сформировать некоторый набор и возвратить его, передача владения естественна. В этом случае самый простой способ — возвратить контейнер с элементами. Он подходит, если вы чётко знаете контекст использования функции и не собираетесь его менять. При этом можно полагаться на NRVO:</p>

<pre><code class="language-cpp">class Cohort {
public:
    // ...
    PushResult PushStudents() {
        StudentList students_to_push = GetNotReadyStudents();
        for (Student&amp; student : students_to_push) {
            PushStudent(student);
        }

        return students_to_push;
    }
};
</code></pre>

<h3>Возврат контейнера по ссылке</h3>

<p>Класс может реализовывать геттер для получения контейнера без передачи владения. В этом случае удобно использовать псевдоним, чтобы можно было поменять контейнер, ничего не нарушив в месте его применения:</p>

<pre><code class="language-cpp">class Cohort {
public:
    using StudentMap = std::unordered_map&lt;int, Student&gt;;

    const StudentMap&amp; GetAllStudents() const {
        return all_students_;
    }

private:
    StudentMap all_students_;
};
</code></pre>

<p>Возвращать неконстантную ссылку, чтобы произвести какие-либо операции с контейнером, не нужно. Это может привести к неконсистентности данных класса и отбирает у него возможность контролировать своё содержимое, что часто приводит к ошибкам:</p>

<pre><code class="language-cpp">class Cohort {
public:
    using StudentMap = std::unordered_map&lt;int, Student&gt;;

    // плохо:
    StudentMap&amp; GetAllStudents() {
        return all_students_;
    }

private:
    StudentMap all_students_;
};

// ...

Cohort cohort100;

// ...

// не делайте так:
cohort100.GetAllStudents[new_id] = move(new_student);

</code></pre>

<p>Для допустимых изменений контейнера класса используйте отдельные методы:</p>

<pre><code class="language-cpp">class Cohort {
public:
    using StudentMap = std::unordered_map&lt;int, Student&gt;;

    const StudentMap&amp; GetAllStudents() const {
        return all_students_;
    }

    int RegisterStudent(Student new_student) {
        // тут можно выполнить дополнительную инициализацию,
        // например открыть студенту доступ к первому спринту
    }

private:
    StudentMap all_students_;
};

// ...

Cohort cohort100;

// ...

int new_id = cohort100.RegisterStudent(move(new_student));
</code></pre>

<h3>Возврат пары итераторов</h3>

<hr>

<p>Отметьте, в каких случаях уместен возврат пары итераторов. Выберите один или несколько вариантов:</p>

<ul>
<li><p>При передаче владения.</p></li>

<li><p>Без передачи владения.</p></li>

<li><p>Никогда не уместен.</p></li>
</ul>

<p>Возвращать пару итераторов можно, только если владение не передаётся. Иначе получится, что функция отказалась от владения объектами и возвращённые итераторы указывают в пустоту. Это приведёт к неопределённому поведению.</p>

<p>Возврат пары итераторов более универсален, чем возврат контейнера. Классы могут определить методы <code>begin</code> и <code>end</code> для последующего использования в <code>for</code> по диапазону. С таким вы уже сталкивались при написании класса поисковой системы:</p>

<pre><code class="language-cpp">class Cohort {
public:
    using StudentMap = std::unordered_map&lt;int, Student&gt;;

    StudentMap::const_iterator begin() const {
        return all_students_.begin();
    }

    StudentMap::const_iterator end() const {
        return all_students_.end();
    }

private:
    StudentMap all_students_;
};

// ...

Cohort cohort100;

// ...

for (const auto&amp; student: cohort100) {
    // ...
}
</code></pre>

<h3>Приём выходного итератора</h3>

<p>Вы знаете немало алгоритмов, которые принимают итератор для того, чтобы выдавать ответ. Например, <code>std::copy</code>:</p>

<pre><code class="language-cpp">template&lt;class InputIt, class OutputIt&gt;
OutputIt copy(InputIt first, InputIt last, OutputIt d_first);
</code></pre>

<hr>

<p>Передаёт ли <code>copy</code> владение какими-либо объектами?</p>

<ul>
<li><p>Передаёт.</p></li>

<li><p>Не передаёт.</p></li>

<li><p>Зависит от шаблонных параметров.</p></li>
</ul>

<p>Этот алгоритм передаёт владение, но только не теми объектами, которые ему переданы на вход, а их копиями. Его реализация может быть крайне простой:</p>

<pre><code class="language-cpp">template&lt;class InputIt, class OutputIt&gt;
OutputIt copy(InputIt first, InputIt last, OutputIt d_first) {
    while (first != last) {
        *d_first++ = *first++;
    }
    return d_first;
}
</code></pre>

<p>Этот алгоритм записывает прямо в итератор, инкрементируя его после каждой записи. В качестве выходного итератора можно передать как специальный итератор c побочным эффектом разыменования <code>back_inserter</code> или <code>inserter</code>, так и обычный итератор. Но если передаётся обычный итератор, нужно убедиться, что в контейнере уже достаточно места для новых элементов.</p>

<p>Ещё один пример необычного итератора, который можно использовать для возврата из функции — <code>ostream_iterator</code> из заголовка <code>&lt;iterator&gt;</code>. Полученные данные он пишет напрямую в указанный поток.</p>

<p>Напишем функцию, выдающую простые числа на заданном диапазоне:</p>

<pre><code class="language-cpp">#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;

using namespace std;

// не самый эффективный тест на простоту числа
bool IsPrime(int n) {
    if (std::abs(n) &lt; 2) {
        return false;
    }

    for (int i = 2; i * i &lt;= n; ++i) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}

template&lt;typename OutputIt&gt;
void GetPrimeNumbers(int from, int to, OutputIt output_iter) {
    for (int i = from; i &lt; to; ++i) {
        if (IsPrime(i)) {
            *output_iter++ = i;
        }
    }
}

int main() {
    // результат выведен в cout через пробел
    GetPrimeNumbers(0, 100, ostream_iterator&lt;int&gt;(cout, &quot; &quot;));
}
</code></pre>

<p>Результат выполнения программы:</p>

<pre><code class="language-cpp">2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
</code></pre>

<p>Выходной итератор — это довольно универсальный способ возврата набора из функции с передачей владения. В отличие от прямого возврата вектора, он позволяет записывать в данные любой контейнер, причём даже если в нём уже есть элементы.</p>

<h3>Приём выходного указателя или span</h3>

<p>Метод потоков ввода <code>read</code> принимает указатель и количество желаемых элементов. Он реализован для общих потоков произвольного типа. Для привычного случая потоков <code>char</code> сигнатура могла бы быть такой:</p>

<pre><code class="language-cpp">istream&amp; istream::read(char* buffer, int buffer_size);
</code></pre>

<p>Этот метод возврата вполне допустим при соблюдении следующих условий:</p>

<ul>
<li>заранее известно, сколько нужно объектов, и под них выделена память;</li>
<li>объекты располагаются в памяти последовательно, например хранятся в векторе или <code>array</code>;</li>
<li>объекты можно сконструировать заранее, а владение принять через присваивание.</li>
</ul>

<p>В стандарте C++20 можно использовать <code>span</code>, чтобы передавать один параметр вместо двух. О <code>span</code> говорилось в уроке о передаче множества объектов в функцию. Дополнительно можно прочитать в <a href="https://en.cppreference.com/w/cpp/container/span">документации</a>.</p>

<h3>Приём callback</h3>

<p>В предыдущей теме вы подробно изучили вопрос передачи функционального объекта в качестве параметра. Его же можно использовать и для возврата из функции. Этот способ напоминает выходной итератор, вместо которого можно применить callback, вызываемый при поступлении нового объекта:</p>

<pre><code class="language-cpp">template &lt;typename Callback&gt;
void GetPrimeNumbers(int from, int to, Callback callback) {
    for (int i = from; i &lt; to; ++i) {
        if (IsPrime(i)) {
            callback(i);
        }
    }
}

int main() {
    GetPrimeNumbers(0, 100, [](int p){
        cout &lt;&lt; p &lt;&lt; &quot; &quot;sv;
    });
}
</code></pre>

<p>Использовать callback вместо уже готового итератора немного сложнее, потому что нужно написать лямбда-функцию, но зато этот способ ещё более универсальный. Например, так можно вывести только числа-близнецы:</p>

<pre><code class="language-cpp">#include &lt;optional&gt;

// ...

template&lt;typename Callback&gt;
void GetPrimeNumbers(int from, int to, Callback callback) {
    for (int i = from; i &lt; to; ++i) {
        if (IsPrime(i)) {
            callback(i);
        }
    }
}

int main() {
    optional&lt;int&gt; prev;
    GetPrimeNumbers(0, 100, [&amp;prev](int p) {
        if (prev &amp;&amp; p - *prev == 2) {
            cout &lt;&lt; *prev &lt;&lt; &quot;-&quot;sv &lt;&lt; p &lt;&lt; &quot; &quot;sv;
        }
        prev = p;
    });
}
</code></pre>

<p>Вывод программы:</p>

<pre><code class="language-cpp">3-5 5-7 11-13 17-19 29-31 41-43 59-61 71-73
</code></pre>

<p>У возврата через callback много преимуществ:</p>

<ul>
<li>это эффективно,</li>
<li>можно использовать как с передачей владения, так и без неё,</li>
<li>наиболее универсальный способ, можно реализовать любую прихоть,</li>
<li>можно начать обрабатывать значения по ходу их появления, избегая создания контейнера,</li>
<li>лямбда-функция может дать команду остановить вычисление через возвращаемое значение.</li>
</ul>

<p>Но также есть и недостатки:</p>

<ul>
<li>иногда лямбда-функции трудно читать,</li>
<li>их не протестировать юнит-тестами,</li>
<li>эффективный способ приёма через шаблонный параметр имеет невнятную сигнатуру.</li>
</ul>

<h3>Будущее</h3>

<p>В C++20 введено понятие корутин — это специальные функции, которые могут возвратить значение, не прекращая свою работу, чтобы потом сделать ещё возвраты. Корутины нарушают привычную логику стека вызовов и в C++20 реализованы не полностью. Полная поддержка корутин ожидается только в стандарте 2023 года.</p>

<h3>Подведём итоги</h3>

<p>С возвратом набора однотипных объектов всё сложнее, чем с передачей его в функцию. При передаче владение объектами и контейнером продолжает находиться под контролем вызывающей функции. А при возврате функция, создавшая набор объектов, завершается и прекращает владение чем-либо.</p>

<p>Подведём итог урока, выбрав наиболее приемлемый способ получения набора объектов для разных случаев.</p>

<p>Возвращается уже готовый набор объектов, которыми владеет класс. В этом случае возвращаем контейнер по константной ссылке:</p>

<pre><code class="language-cpp">class Cohort {
public:
    const std::vector&lt;int&gt;&amp; GetGradesByStudent(int student_id) const {
        return grades_by_student_.at(student_id);
    }

private:
    std::map&lt;int, std::vector&lt;int&gt;&gt; grades_by_student_;
};
</code></pre>

<p>Мы точно знаем, в каком контексте будет использоваться возвращаемое значение, либо производительность не важна. В этом случае возвращаем контейнер:</p>

<pre><code class="language-cpp">class Cohort {
public:
    std::vector&lt;int&gt; GetUngradedStudents() const {
        std::vector&lt;int&gt; result;
        for (const auto&amp; [id, grades] : grades_by_student_) {
            if (!grades.empty()) {
                result.push_back(id);
            }
        }
        return result;
    }

private:
    std::map&lt;int, std::vector&lt;int&gt;&gt; grades_by_student_;
};
</code></pre>

<p>Хранить элементы — это основное назначение класса, и мы хотим итерироваться по объекту класса. Тогда нужен возврат итераторов методами <code>begin</code> и <code>end</code>.</p>

<pre><code class="language-cpp">class JSONArray {
public:
    using Container = std::vector&lt;JSONelement&gt;;

    Container::iterator begin() {
        return elements_.begin();
    }
    
    Container::iterator end() {
        return elements_.end();
    }

    // константные итераторы и cbegin, cend

private:
    Container elements_;
};
</code></pre>

<p>Хотим позволить вызывающей стороне складывать в любой контейнер по её желанию или даже сразу выводить в поток. В этом случае принимаем выходной итератор:</p>

<pre><code class="language-cpp">class Cohort {
public:
    template &lt;typename OutputIt&gt;
    std::vector&lt;int&gt; GetUngradedStudents(OutputIt dst) const {
        std::vector&lt;int&gt; result;
        for (const auto&amp; [id, grades] : grades_by_student_) {
            if (!grades.empty()) {
                *dst++ = id;
            }
        }
        return result;
    }

private:
    std::map&lt;int, std::vector&lt;int&gt;&gt; grades_by_student_;
};
</code></pre>

<p>Предполагаем, что вызывающая сторона может не сохранять объекты, а сразу обрабатывать, либо хотим дать ей возможность прервать вычисление. Тогда нужен наиболее универсальный способ — возврат через callback:</p>

<pre><code class="language-cpp">template&lt;typename Callback&gt;
void GetPrimeNumbers(int from, int to, Callback callback) {
    for (int i = from; i &lt; to; ++i) {
        if (IsPrime(i)) {
            callback(i);
        }
    }
}
</code></pre>

</body>
</html>
