<!DOCTYPE html>
<html>
<head>
  <title>Функция vs метод класса</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta charset="utf-8">
<style>body{font-family:Helvetica,arial,sans-serif;font-size:14px;line-height:1.6;background-color:#fff;padding:30px;color:#333;max-width:1140px;margin:0 auto}body > :first-child{margin-top:0!important}body > :last-child{margin-bottom:0!important}a{color:#4183C4;text-decoration:none}a.absent{color:#c00}a.anchor{display:block;padding-left:30px;margin-left:-30px;cursor:pointer;position:absolute;top:0;left:0;bottom:0}h1,h2,h3,h4,h5,h6{margin:20px 0 10px;padding:0;font-weight:700;-webkit-font-smoothing:antialiased;cursor:text;position:relative}h2:first-child,h1:first-child,h1:first-child + h2,h3:first-child,h4:first-child,h5:first-child,h6:first-child{margin-top:0;padding-top:0}h1:hover a.anchor,h2:hover a.anchor,h3:hover a.anchor,h4:hover a.anchor,h5:hover a.anchor,h6:hover a.anchor{text-decoration:none}h1 tt,h1 code{font-size:inherit}h2 tt,h2 code{font-size:inherit}h3 tt,h3 code{font-size:inherit}h4 tt,h4 code{font-size:inherit}h5 tt,h5 code{font-size:inherit}h6 tt,h6 code{font-size:inherit}h1{font-size:28px;color:#000}h2{font-size:24px;border-bottom:1px solid #ccc;color:#000}h3{font-size:18px}h4{font-size:16px}h5{font-size:14px}h6{color:#777;font-size:14px}p,blockquote,ul,ol,dl,li,table,pre{margin:15px 0}hr {padding:0;margin-bottom:-8px;height:1px;border:none;background:black}body > h2:first-child{margin-top:0;padding-top:0}body > h1:first-child{margin-top:0;padding-top:0}body > h1:first-child + h2{margin-top:0;padding-top:0}body > h3:first-child,body > h4:first-child,body > h5:first-child,body > h6:first-child{margin-top:0;padding-top:0}a:first-child h1,a:first-child h2,a:first-child h3,a:first-child h4,a:first-child h5,a:first-child h6{margin-top:0;padding-top:0}h1 p,h2 p,h3 p,h4 p,h5 p,h6 p{margin-top:0}li p.first{display:inline-block}ul,ol{padding-left:30px}ul :first-child,ol :first-child{margin-top:0}ul :last-child,ol :last-child{margin-bottom:0}dl{padding:0}dl dt{font-size:14px;font-weight:700;font-style:italic;padding:0;margin:15px 0 5px}dl dt:first-child{padding:0}dl dt > :first-child{margin-top:0}dl dt > :last-child{margin-bottom:0}dl dd{margin:0 0 15px;padding:0 15px}dl dd > :first-child{margin-top:0}dl dd > :last-child{margin-bottom:0}blockquote{border-left:4px solid #ddd;padding:0 15px;color:#777}blockquote > :first-child{margin-top:0}blockquote > :last-child{margin-bottom:0}table{padding:0}table tr{border-top:1px solid #ccc;background-color:#fff;margin:0;padding:0}table tr:nth-child(2n){background-color:#f8f8f8}table tr th{font-weight:700;border:1px solid #ccc;text-align:left;margin:0;padding:6px 13px}table tr td{border:1px solid #ccc;text-align:left;margin:0;padding:6px 13px}table tr th :first-child,table tr td :first-child{margin-top:0}table tr th :last-child,table tr td :last-child{margin-bottom:0}img{max-width:100%;display:block}span.frame{display:block;overflow:hidden}span.frame > span{border:1px solid #ddd;display:block;float:left;overflow:hidden;margin:13px 0 0;padding:7px;width:auto}span.frame span img{display:block;float:left}span.frame span span{clear:both;color:#333;display:block;padding:5px 0 0}span.align-center{display:block;overflow:hidden;clear:both}span.align-center > span{display:block;overflow:hidden;margin:13px auto 0;text-align:center}span.align-center span img{margin:0 auto;text-align:center}span.align-right{display:block;overflow:hidden;clear:both}span.align-right > span{display:block;overflow:hidden;margin:13px 0 0;text-align:right}span.align-right span img{margin:0;text-align:right}span.float-left{display:block;margin-right:13px;overflow:hidden;float:left}span.float-left span{margin:13px 0 0}span.float-right{display:block;margin-left:13px;overflow:hidden;float:right}span.float-right > span{display:block;overflow:hidden;margin:13px auto 0;text-align:right}code,tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px}pre code{margin:0;padding:0;white-space:pre;border:none;background:transparent}.highlight pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre code,pre tt{background-color:transparent;border:none}.slasher{color:#000000}</style></head>
<body>

<h1>Функция vs метод класса</h1>

<p>Язык С++ предоставляет программисту несколько вариантов оформления функции.</p>

<p>С одной стороны, методы класса удобны тем, что они имеют доступ к полям, иначе говоря — к глобальному контексту класса. Можно не передавать поля класса как аргументы, и не нужно вызывать дополнительных функций, чтобы получить к ним доступ. С другой стороны, чем больше в классе методов, меняющих состояние объекта, тем больше шансов, что с объектом будут происходить изменения, и тем больше шансов, что эти изменения будут нежелательными. Ошибки при проектировании методов класса повышают опасность неверного поведения объекта.</p>

<p>Хотелось бы понять, как выбрать между оформлением блока кода в качестве функции или в качестве метода класса.</p>

<p>Кроме уже указанного чисто технического отличия, есть ещё одно. Класс олицетворяет собой некий объект, а методы — действия, которые объект способен совершать и которые можно совершать над объектом. Не всегда блок кода, который программист хочет выделить, можно отнести к действию объекта. Иногда это просто повторяющиеся действия или действие, требующее отдельного названия для удобства чтения. В таких случаях выбор обычной функции выглядит предпочтительнее.</p>

<p>Вернём в задачу о демографических показателях обратно все функции и сделаем её даже ещё красивее, чем раньше. Мы добавим класс, объединяющий в себе функции, которые относятся к вычислению статистики. Назовём этот класс <code>StatsManager</code> и поместим в него три статических метода <code>ReadPersons</code>, <code>ComputeStats</code> и <code>PrintStats</code>.</p>

<h1>Решение задачи о демографических показателях с использованием класса</h1>

<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

enum class Gender { FEMALE, MALE };

struct Person {
    int age;
    Gender gender;
    bool is_employed;
};

struct AgeStats {
    int total;
    int females;
    int males;
    int employed_females;
    int unemployed_females;
    int employed_males;
    int unemployed_males;
};

template &lt;typename InputIt&gt;
int ComputeMedianAge(InputIt range_begin, InputIt range_end) {
    if (range_begin == range_end) {
        return 0;
    }
    vector&lt;typename InputIt::value_type&gt; range_copy(range_begin, range_end);
    auto middle = range_copy.begin() + range_copy.size() / 2;
    nth_element(range_copy.begin(), middle, range_copy.end(), [](const Person&amp; lhs, const Person&amp; rhs) {
        return lhs.age &lt; rhs.age;
    });
    return middle-&gt;age;
}

class StatsManager {
public:
    static vector&lt;Person&gt; ReadPersons(istream&amp; in_stream = cin);
    static AgeStats ComputeStats(vector&lt;Person&gt; persons);
    static void PrintStats(const AgeStats&amp; stats, ostream&amp; out_stream = cout);
};

vector&lt;Person&gt; StatsManager::ReadPersons(istream&amp; in_stream) {
    int person_count;
    in_stream &gt;&gt; person_count;
    vector&lt;Person&gt; persons;
    persons.reserve(person_count);
    for (int i = 0; i &lt; person_count; ++i) {
        int age, gender, is_employed;
        in_stream &gt;&gt; age &gt;&gt; gender &gt;&gt; is_employed;
        Person person{age, static_cast&lt;Gender&gt;(gender), is_employed == 1};
        persons.push_back(person);
    }
    return persons;
}

AgeStats StatsManager::ComputeStats(vector&lt;Person&gt; persons) {
    auto females_end = partition(persons.begin(), persons.end(), [](const Person&amp; p) {
        return p.gender == Gender::FEMALE;
    });
    auto employed_females_end = partition(persons.begin(), females_end, [](const Person&amp; p) {
        return p.is_employed;
    });
    auto employed_males_end = partition(females_end, persons.end(), [](const Person&amp; p) {
        return p.is_employed;
    });

    return {ComputeMedianAge(begin(persons), end(persons)), ComputeMedianAge(begin(persons), females_end),
            ComputeMedianAge(females_end, end(persons)), ComputeMedianAge(begin(persons), employed_females_end),
            ComputeMedianAge(employed_females_end, females_end), ComputeMedianAge(females_end, employed_males_end),
            ComputeMedianAge(employed_males_end, end(persons))};
}

void StatsManager::PrintStats(const AgeStats&amp; stats, ostream&amp; out_stream) {
    out_stream &lt;&lt; &quot;Median age = &quot; &lt;&lt; stats.total &lt;&lt; endl
               &lt;&lt; &quot;Median age for females = &quot; &lt;&lt; stats.females &lt;&lt; endl
               &lt;&lt; &quot;Median age for males = &quot; &lt;&lt; stats.males &lt;&lt; endl
               &lt;&lt; &quot;Median age for employed females = &quot; &lt;&lt; stats.employed_females &lt;&lt; endl
               &lt;&lt; &quot;Median age for unemployed females = &quot; &lt;&lt; stats.unemployed_females &lt;&lt; endl
               &lt;&lt; &quot;Median age for employed males = &quot; &lt;&lt; stats.employed_males &lt;&lt; endl
               &lt;&lt; &quot;Median age for unemployed males = &quot; &lt;&lt; stats.unemployed_males &lt;&lt; endl;
}

int main() {
    StatsManager::PrintStats(StatsManager::ComputeStats(StatsManager::ReadPersons()));
    return 0;
}
</code></pre>

<p>Методы класса <code>StatsManager</code> статические, так как неясно, к какому объекту их применять. После логического объединения этих функций в методы класса нам пришлось везде добавить префиксы <code>StatsManager::</code>. Теперь функция <code>main</code> выглядит так:</p>

<pre><code class="language-cpp">StatsManager::PrintStats(StatsManager::ComputeStats(StatsManager::ReadPersons()));
</code></pre>

<p>Сразу видно, что все функции относятся к вычислению статистики по демографическим показателям. Но в программе так и не понадобился объект класса <code>StatsManager</code>. Была только потребность объединить функции. В этом случае можно было бы обойтись созданием пространства имён. Оно решило бы задачу программиста по логическому объединению, но не создавало бы лишних классов, структур или других сущностей. Вот как выглядит решение задачи, если убрать из него искусственный класс и добавить пространство имён:</p>

<pre><code class="language-cpp">namespace stats_manager {
    vector&lt;Person&gt; ReadPersons(istream&amp; in_stream = cin);
    AgeStats ComputeStats(vector&lt;Person&gt; persons);
    void PrintStats(const AgeStats&amp; stats, ostream&amp; out_stream = cout);
};
</code></pre>

<p>Лучше не создавать отдельный класс, даже если вам кажется, что в будущем глобальный контекст появится. Начните с отдельных функций или с пространства имён, а по мере изменения требований к коду станет ясно, как именно должен выглядеть класс и должен ли он существовать вообще.</p>

<hr>

<p>Что может служить сигналом того, что требуется объединить функции в класс?</p>

<ul>
<li><p>Несколько функций принимают одинаковый список аргументов</p></li>

<li><p>Список аргументов функции становится слишком длинным: более четырёх аргументов.</p></li>

<li><p>Функции принимают в качестве аргумента объект одного и того же класса.</p></li>

<li><p>В программе есть баг, и вы подозреваете в нём несколько функций.</p></li>
</ul>

</body>
</html>
