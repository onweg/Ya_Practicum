<!DOCTYPE html>
<html>
<head>
  <title>Конструкторы и деструкторы</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta charset="utf-8">
<style>body{font-family:Helvetica,arial,sans-serif;font-size:14px;line-height:1.6;background-color:#fff;padding:30px;color:#333;max-width:1140px;margin:0 auto}body > :first-child{margin-top:0!important}body > :last-child{margin-bottom:0!important}a{color:#4183C4;text-decoration:none}a.absent{color:#c00}a.anchor{display:block;padding-left:30px;margin-left:-30px;cursor:pointer;position:absolute;top:0;left:0;bottom:0}h1,h2,h3,h4,h5,h6{margin:20px 0 10px;padding:0;font-weight:700;-webkit-font-smoothing:antialiased;cursor:text;position:relative}h2:first-child,h1:first-child,h1:first-child + h2,h3:first-child,h4:first-child,h5:first-child,h6:first-child{margin-top:0;padding-top:0}h1:hover a.anchor,h2:hover a.anchor,h3:hover a.anchor,h4:hover a.anchor,h5:hover a.anchor,h6:hover a.anchor{text-decoration:none}h1 tt,h1 code{font-size:inherit}h2 tt,h2 code{font-size:inherit}h3 tt,h3 code{font-size:inherit}h4 tt,h4 code{font-size:inherit}h5 tt,h5 code{font-size:inherit}h6 tt,h6 code{font-size:inherit}h1{font-size:28px;color:#000}h2{font-size:24px;border-bottom:1px solid #ccc;color:#000}h3{font-size:18px}h4{font-size:16px}h5{font-size:14px}h6{color:#777;font-size:14px}p,blockquote,ul,ol,dl,li,table,pre{margin:15px 0}hr {padding:0;margin-bottom:-8px;height:1px;border:none;background:black}body > h2:first-child{margin-top:0;padding-top:0}body > h1:first-child{margin-top:0;padding-top:0}body > h1:first-child + h2{margin-top:0;padding-top:0}body > h3:first-child,body > h4:first-child,body > h5:first-child,body > h6:first-child{margin-top:0;padding-top:0}a:first-child h1,a:first-child h2,a:first-child h3,a:first-child h4,a:first-child h5,a:first-child h6{margin-top:0;padding-top:0}h1 p,h2 p,h3 p,h4 p,h5 p,h6 p{margin-top:0}li p.first{display:inline-block}ul,ol{padding-left:30px}ul :first-child,ol :first-child{margin-top:0}ul :last-child,ol :last-child{margin-bottom:0}dl{padding:0}dl dt{font-size:14px;font-weight:700;font-style:italic;padding:0;margin:15px 0 5px}dl dt:first-child{padding:0}dl dt > :first-child{margin-top:0}dl dt > :last-child{margin-bottom:0}dl dd{margin:0 0 15px;padding:0 15px}dl dd > :first-child{margin-top:0}dl dd > :last-child{margin-bottom:0}blockquote{border-left:4px solid #ddd;padding:0 15px;color:#777}blockquote > :first-child{margin-top:0}blockquote > :last-child{margin-bottom:0}table{padding:0}table tr{border-top:1px solid #ccc;background-color:#fff;margin:0;padding:0}table tr:nth-child(2n){background-color:#f8f8f8}table tr th{font-weight:700;border:1px solid #ccc;text-align:left;margin:0;padding:6px 13px}table tr td{border:1px solid #ccc;text-align:left;margin:0;padding:6px 13px}table tr th :first-child,table tr td :first-child{margin-top:0}table tr th :last-child,table tr td :last-child{margin-bottom:0}img{max-width:100%;display:block}span.frame{display:block;overflow:hidden}span.frame > span{border:1px solid #ddd;display:block;float:left;overflow:hidden;margin:13px 0 0;padding:7px;width:auto}span.frame span img{display:block;float:left}span.frame span span{clear:both;color:#333;display:block;padding:5px 0 0}span.align-center{display:block;overflow:hidden;clear:both}span.align-center > span{display:block;overflow:hidden;margin:13px auto 0;text-align:center}span.align-center span img{margin:0 auto;text-align:center}span.align-right{display:block;overflow:hidden;clear:both}span.align-right > span{display:block;overflow:hidden;margin:13px 0 0;text-align:right}span.align-right span img{margin:0;text-align:right}span.float-left{display:block;margin-right:13px;overflow:hidden;float:left}span.float-left span{margin:13px 0 0}span.float-right{display:block;margin-left:13px;overflow:hidden;float:right}span.float-right > span{display:block;overflow:hidden;margin:13px auto 0;text-align:right}code,tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px}pre code{margin:0;padding:0;white-space:pre;border:none;background:transparent}.highlight pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre code,pre tt{background-color:transparent;border:none}.slasher{color:#000000}</style></head>
<body>

<h1>Конструкторы и деструкторы</h1>

<p>В прошлом уроке мы раскрыли секрет волшебной шляпы. Указатель <code>vtable</code>, таблица виртуальных методов и позднее связывание — три элемента, на которых строится механизм фокуса. Мы обнаружили, что в каждом объекте содержится 8 дополнительных байт. Это потайное дно, где хранится указатель на виртуальную таблицу.</p>

<p>Но кроме этих 8 байт для указателя программе нужно где-то хранить сами таблицы. Вы уже легко оперируете понятием алгоритмической сложности программы. Однако кроме оценки количества операций важно уметь оценивать количество затраченной памяти.</p>

<p>Принцип оценки тот же: насколько быстро растёт объём затрачиваемой памяти в зависимости от входных параметров. Это называется <strong>оценка пространственной сложности</strong>.</p>

<hr>

<p>В терминах пространственной сложности, как вы считаете, сколько памяти будет затрачено на хранение виртуальных таблиц для объектов класса? Здесь <code>N</code> — количество объектов одного класса с виртуальными методами в программе.</p>

<ul>
<li><p>O(1)</p></li>

<li><p>O(N)</p></li>

<li><p>O(N^2)</p></li>
</ul>

<p>Убедимся на практике. Сначала разберёмся, где внутри объекта расположен указатель на виртуальную таблицу. Пока мы видели только объекты без полей данных. Добавим в классы из примера поля данных и рассмотрим строение объекта внимательнее:</p>

<pre><code class="language-cpp">class HatWithApples : public MagicHat {
public:
    void WhatInside() const {
        cout &lt;&lt; &quot;Apple&quot;s &lt;&lt; endl;
    }
    bool HasComethingInside() const {
        cout &lt;&lt; &quot;Yes. Something red and tasty&quot;s &lt;&lt; endl;
        return true;
    }

private:
    /* 10 яблок лежало в шляпе */
    int apples_count = 10;
};

class HatWithRabbits : public MagicHat {
public:
    void WhatInside() const {
        cout &lt;&lt; &quot;Rabbit&quot;s &lt;&lt; endl;
    }
    bool HasComethingInside() const {
        cout &lt;&lt; &quot;Yes. Several furry carrot lovers&quot;s &lt;&lt; endl;
        return true;
    }

private:
    /* 3 кролика сидело в шляпе */
    int rabbits_count = 3;
    /* каждому кролику полагается две морковки, чтобы пережить фокус без стресса */
    int carrot_count = 6;
};
</code></pre>

<p>Взгляните на расположение полей в памяти:</p>

<pre><code>*** Dumping AST Record Layout
         0 | class HatWithApples
         0 |   class MagicHat (primary base)
         0 |     (MagicHat vftable pointer)
         8 |   int apples_count
           | [sizeof=16, align=8,
           |  nvsize=16, nvalign=8]

*** Dumping AST Record Layout
         0 | class HatWithRabbits
         0 |   class MagicHat (primary base)
         0 |     (MagicHat vftable pointer)
         8 |   int rabbits_count
        12 |   int carrot_count
           | [sizeof=16, align=8,
           |  nvsize=16, nvalign=8]
</code></pre>

<p>Указатель на виртуальную таблицу остался в начале объекта, вне зависимости от количества полей. Исходя из этого, функция для печати адреса виртуальной таблицы будет выглядеть так:</p>

<pre><code class="language-cpp">void PrintVptr(void* obj) {
    auto ptr = reinterpret_cast&lt;size_t*&gt;(obj);
    cout &lt;&lt; &quot;Vptr : &quot;s &lt;&lt; *ptr &lt;&lt; endl;
}
</code></pre>

<p>Здесь использование <code>reinterpret_cast</code> не приведёт к страданию кроликов. Нам действительно нужно именно так интерпретировать адрес объекта.</p>

<p>Передадим в эту функцию объекты следующим образом:</p>

<pre><code class="language-cpp">HatWithApples apple_hat1;
HatWithApples apple_hat2;
HatWithRabbits rabbit_hat1;
HatWithRabbits rabbit_hat2;
HatWithDoves dove_hat1;
HatWithDoves dove_hat2;

vector&lt;MagicHat*&gt; hats = {&amp;apple_hat1, &amp;apple_hat2, 
                          &amp;rabbit_hat1, &amp;rabbit_hat2, 
                          &amp;dove_hat1, &amp;dove_hat2};
for (auto hat : hats) {
    PrintVptr(hat);
}
</code></pre>

<p>В результате работы программы на экран будет выведено:</p>

<pre><code>Vptr : 4220656
Vptr : 4220656
Vptr : 4220688
Vptr : 4220688
Vptr : 4220624
Vptr : 4220624
</code></pre>

<p>Адреса попарно равны для объектов одинаковых типов. Адреса одинаковые, значит, они ссылаются на одну и ту же таблицу. Это то, чего мы ожидали. Таблица для всех объектов класса одна и внутри каждого объекта класса содержится указатель на неё.</p>

<p>Воспользуемся этой же функцией, печатающей адреса виртуальной таблицы, чтобы выяснить, что происходит с <code>vptr</code> в конструкторах и деструкторах. Создадим на стеке три переменных. Их деструкторы будут вызваны при выходе из функции <code>main</code> автоматически.</p>

<pre><code class="language-cpp">void PrintVptr(void* obj) {
    auto ptr = reinterpret_cast&lt;size_t*&gt;(obj);
    cout &lt;&lt; &quot;Vptr : &quot;s &lt;&lt; *ptr &lt;&lt; endl;
}

class MagicHat {
public:
    MagicHat() {
        cout &lt;&lt; &quot;MagicHat::Ctor : &quot;s;
        PrintVptr(this);
    }
    ~MagicHat() {
        cout &lt;&lt; &quot;MagicHat::Dtor : &quot;s;
        PrintVptr(this);
    ...
};

class HatWithApples : public MagicHat {
public:
    HatWithApples() {
        cout &lt;&lt; &quot;HatWithApples::Ctor : &quot;s;
        PrintVptr(this);
    }
    ~HatWithApples() {
        cout &lt;&lt; &quot;HatWithApples::Dtor : &quot;s;
        PrintVptr(this);
    }
    ...
};

class HatWithRabbits : public MagicHat {
public:
    HatWithRabbits() {
        cout &lt;&lt; &quot;HatWithRabbits::Ctor : &quot;s;
        PrintVptr(this);
    }
    ~HatWithRabbits() {
        cout &lt;&lt; &quot;HatWithRabbits::Dtor : &quot;s;
        PrintVptr(this);
    ...
};

class HatWithDoves : public MagicHat {
public:
    HatWithDoves() {
        cout &lt;&lt; &quot;HatWithDoves::Ctor : &quot;s;
        PrintVptr(this);
    }
    ~HatWithDoves() {
        cout &lt;&lt; &quot;HatWithDoves::Dtor : &quot;s;
        PrintVptr(this);
    }
    ...
};

int main() {
    HatWithApples hat1;
    HatWithRabbits hat2;
    HatWithDoves hat3;
}
</code></pre>

<p>Результат работы программы:</p>

<pre><code class="language-cpp">MagicHat::Ctor : Vptr : 4220880
HatWithApples::Ctor : Vptr : 4220816
MagicHat::Ctor : Vptr : 4220880
HatWithRabbits::Ctor : Vptr : 4220848
MagicHat::Ctor : Vptr : 4220880
HatWithDoves::Ctor : Vptr : 4220784
HatWithDoves::Dtor : Vptr : 4220784
MagicHat::Dtor : Vptr : 4220880
HatWithRabbits::Dtor : Vptr : 4220848
MagicHat::Dtor : Vptr : 4220880
HatWithApples::Dtor : Vptr : 4220816
MagicHat::Dtor : Vptr : 4220880
</code></pre>

<p>Вы уже знаете, почему на экран вывелось так много информации. Внутри каждого объекта прячется объект базового класса. Поэтому каждому объекту вызывается два конструктора, а потом два деструктора соответственно.</p>

<p>Выделим то, что касается одного вида шляпы. Например, шляпы с яблоками:</p>

<pre><code class="language-cpp">MagicHat::Ctor : Vptr : 4220880
HatWithApples::Ctor : Vptr : 4220816
HatWithApples::Dtor : Vptr : 4220816
MagicHat::Dtor : Vptr : 4220880
</code></pre>

<p>В конструкторе базового объекта <code>MagicHat</code> указатель <code>vtpr</code> указывает на одну таблицу, а в конструкторе <code>HatWithApples</code> — уже на другую. Иными словами, указатель <code>vptr</code> перед вызовом конструктора устанавливается на таблицу виртуальных функций того класса, конструктор которого вызывается. Это нужно, чтобы внутри конструктора гарантированно вызывать только методы именно данного класса. Такой механизм гарантирует, что конструктор базового объекта не попытается обратиться к методам класса-наследника, который на данный момент ещё не сконструирован.</p>

<p>С деструкторами, казалось бы, всё так же. Но здесь кроется небольшой подвох.</p>

<hr>

<p>Какой?</p>

<ul>
<li><p>При компиляции не всегда известно, какой динамический тип у удаляемого объекта.</p></li>

<li><p>Деструкторы вызываются в том же порядке, что и конструкторы: сначала базовый объект, потом объект-наследник. Поэтому переставлять указатель <code>vptr</code> не нужно, всё будет работать и без этого.</p></li>

<li><p>Не вижу подвоха. И пример выше это подтверждает. Всё отлично работает.</p></li>
</ul>

<p>Комментарий: При вызове <code>delete</code> должно случится следующее:</p>

<ol>
<li>Вызов деструктора соответствующего класса;</li>
<li>Освобождение динамически выделенной памяти.</li>
</ol>

<p>Но во время компиляции может быть неизвестен динамический тип объекта, поэтому использовать раннее связывание в первом пункте будет невозможно.</p>

<p>Посмотрите на пример:</p>

<pre><code class="language-cpp">MagicHat* hat;
if (...) {
    hat = new HatWithApples();
} else {
    hat = new HatWithRabbits();
}
delete hat;
</code></pre>

<p>В примере выше компилятор не может определить тип удаляемого объекта. Если в этот момент использовать раннее связывание и вызвать деструктор только для <code>MagicHat</code>, не все ресурсы могут быть освобождены корректно. Ведь на самом деле объект имеет другой тип. Более того, компилятор может сообщить вам об опасности через предупреждение:</p>

<pre><code class="language-cpp">warning: deleting object of polymorphic class type 'MagicHat' which has non-virtual destructor might cause undefined behavior [-Wdelete-non-virtual-dtor]
      delete hat;
             ^~~
</code></pre>

<p>В предупреждении есть подсказка, как решить проблему: просто деструктор класса, содержащего виртуальные методы, тоже должен быть виртуальным. Тогда позднее связывание решит задачу, будет вызван деструктор из виртуальной таблицы соответствующего класса. Все ресурсы освободятся.</p>

</body>
</html>
