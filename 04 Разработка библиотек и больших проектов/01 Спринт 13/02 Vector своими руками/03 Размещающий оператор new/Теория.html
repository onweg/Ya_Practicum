<!DOCTYPE html>
<html>
<head>
  <title>Размещающий оператор new</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta charset="utf-8">
<style>body{font-family:Helvetica,arial,sans-serif;font-size:14px;line-height:1.6;background-color:#fff;padding:30px;color:#333;max-width:1140px;margin:0 auto}body > :first-child{margin-top:0!important}body > :last-child{margin-bottom:0!important}a{color:#4183C4;text-decoration:none}a.absent{color:#c00}a.anchor{display:block;padding-left:30px;margin-left:-30px;cursor:pointer;position:absolute;top:0;left:0;bottom:0}h1,h2,h3,h4,h5,h6{margin:20px 0 10px;padding:0;font-weight:700;-webkit-font-smoothing:antialiased;cursor:text;position:relative}h2:first-child,h1:first-child,h1:first-child + h2,h3:first-child,h4:first-child,h5:first-child,h6:first-child{margin-top:0;padding-top:0}h1:hover a.anchor,h2:hover a.anchor,h3:hover a.anchor,h4:hover a.anchor,h5:hover a.anchor,h6:hover a.anchor{text-decoration:none}h1 tt,h1 code{font-size:inherit}h2 tt,h2 code{font-size:inherit}h3 tt,h3 code{font-size:inherit}h4 tt,h4 code{font-size:inherit}h5 tt,h5 code{font-size:inherit}h6 tt,h6 code{font-size:inherit}h1{font-size:28px;color:#000}h2{font-size:24px;border-bottom:1px solid #ccc;color:#000}h3{font-size:18px}h4{font-size:16px}h5{font-size:14px}h6{color:#777;font-size:14px}p,blockquote,ul,ol,dl,li,table,pre{margin:15px 0}hr {padding:0;margin-bottom:-8px;height:1px;border:none;background:black}body > h2:first-child{margin-top:0;padding-top:0}body > h1:first-child{margin-top:0;padding-top:0}body > h1:first-child + h2{margin-top:0;padding-top:0}body > h3:first-child,body > h4:first-child,body > h5:first-child,body > h6:first-child{margin-top:0;padding-top:0}a:first-child h1,a:first-child h2,a:first-child h3,a:first-child h4,a:first-child h5,a:first-child h6{margin-top:0;padding-top:0}h1 p,h2 p,h3 p,h4 p,h5 p,h6 p{margin-top:0}li p.first{display:inline-block}ul,ol{padding-left:30px}ul :first-child,ol :first-child{margin-top:0}ul :last-child,ol :last-child{margin-bottom:0}dl{padding:0}dl dt{font-size:14px;font-weight:700;font-style:italic;padding:0;margin:15px 0 5px}dl dt:first-child{padding:0}dl dt > :first-child{margin-top:0}dl dt > :last-child{margin-bottom:0}dl dd{margin:0 0 15px;padding:0 15px}dl dd > :first-child{margin-top:0}dl dd > :last-child{margin-bottom:0}blockquote{border-left:4px solid #ddd;padding:0 15px;color:#777}blockquote > :first-child{margin-top:0}blockquote > :last-child{margin-bottom:0}table{padding:0}table tr{border-top:1px solid #ccc;background-color:#fff;margin:0;padding:0}table tr:nth-child(2n){background-color:#f8f8f8}table tr th{font-weight:700;border:1px solid #ccc;text-align:left;margin:0;padding:6px 13px}table tr td{border:1px solid #ccc;text-align:left;margin:0;padding:6px 13px}table tr th :first-child,table tr td :first-child{margin-top:0}table tr th :last-child,table tr td :last-child{margin-bottom:0}img{max-width:100%;display:block}span.frame{display:block;overflow:hidden}span.frame > span{border:1px solid #ddd;display:block;float:left;overflow:hidden;margin:13px 0 0;padding:7px;width:auto}span.frame span img{display:block;float:left}span.frame span span{clear:both;color:#333;display:block;padding:5px 0 0}span.align-center{display:block;overflow:hidden;clear:both}span.align-center > span{display:block;overflow:hidden;margin:13px auto 0;text-align:center}span.align-center span img{margin:0 auto;text-align:center}span.align-right{display:block;overflow:hidden;clear:both}span.align-right > span{display:block;overflow:hidden;margin:13px 0 0;text-align:right}span.align-right span img{margin:0;text-align:right}span.float-left{display:block;margin-right:13px;overflow:hidden;float:left}span.float-left span{margin:13px 0 0}span.float-right{display:block;margin-left:13px;overflow:hidden;float:right}span.float-right > span{display:block;overflow:hidden;margin:13px auto 0;text-align:right}code,tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px}pre code{margin:0;padding:0;white-space:pre;border:none;background:transparent}.highlight pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre code,pre tt{background-color:transparent;border:none}.slasher{color:#000000}</style></head>
<body>

<h1>Размещающий оператор new</h1>

<p>В прошлом уроке вы узнали, что настоящий класс <code>vector</code> конструирует свои объекты в сырой памяти только при необходимости. Под сырой памятью здесь понимается область памяти, которой владеет <code>vector</code> и в которой пока не создано ни одного объекта.</p>

<p>Ранее вы изучали способы работы с памятью, при которых создание объекта неотделимо от выделения памяти для его хранения.</p>

<ul>
<li>Объявление локальной переменной внутри функции автоматически выделяет память для её хранения. Выход из блока, где она объявлена, автоматически вызывал деструктор объекта и освобождал занимаемую им память.</li>
<li>Объявление глобальной переменной выделяет под неё память в момент запуска программы. При завершении программы автоматически вызывается деструктор объекта, а память возвращается операционной системе.</li>
<li>Операторы <code>new</code> и <code>new[]</code> выделяют память в куче и конструируют объекты и массивы. Соответствующие им операторы <code>delete</code> и <code>delete[]</code> вызывают деструкторы объектов и возвращают память обратно в кучу.</li>
</ul>

<p>В этом уроке вы увидите, как выделять сырую память в куче и на стеке и вручную создавать и удалять в ней объекты. А ещё создадите упрощённый аналог класса <code>optional</code>.</p>

<p>Чтобы показать, как создаётся объект, используем класс <code>Cat</code>. Он оповещает о своём конструировании и разрушении:</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;new&gt;
#include &lt;string&gt;

using namespace std;

class Cat {
public:
    Cat(string name, int age)
        : name_(move(name))
        , age_(age)  //
    {
        cout &lt;&lt; &quot;Hello from &quot; &lt;&lt; name_ &lt;&lt; endl;
    }

    ~Cat() {
        cout &lt;&lt; &quot;Goodbye from &quot;sv &lt;&lt; name_ &lt;&lt; endl;
    }

    void SayHello() const {
        cout &lt;&lt; &quot;Meow, my name is &quot;sv &lt;&lt; name_ &lt;&lt; &quot;. I'm &quot;sv &lt;&lt; age_ &lt;&lt; &quot; year old.&quot;sv &lt;&lt; endl;
    }

private:
    string name_;
    int age_;
};
</code></pre>

<p>Убедимся, что если создать кота в автоматической памяти, он будет справляться с обязанностями:</p>

<pre><code class="language-cpp">int main() {
    Cat cat(&quot;Tom&quot;s, 2);
    cat.SayHello();
}
</code></pre>

<pre><code>Hello from Tom
Meow, my name is Tom. I'm 2 year old.
Goodbye from Tom
</code></pre>

<p>Кот работает корректно:</p>

<pre><code class="language-cpp">int main() {
    Cat* cat = new Cat(&quot;Leo&quot;s, 3);
    cat-&gt;SayHello();
    delete cat;
}
</code></pre>

<pre><code>Hello from Leo
Meow, my name is Leo. I'm 3 year old.
Goodbye from Leo
</code></pre>

<p>Чтобы не забыть вызвать <code>delete</code> для удаления объекта, используйте умный указатель <code>unique_ptr</code>:</p>

<pre><code class="language-cpp">int main() {
    auto cat = make_unique&lt;Cat&gt;(&quot;Felix&quot;s, 4);
    cat-&gt;SayHello();
}
</code></pre>

<pre><code>Hello from Felix
Meow, my name is Felix. I'm 4 year old.
Goodbye from Felix
</code></pre>

<p>Это были знакомые вам способы создания объектов. В них выделение памяти и конструирование объекта выполнялись транзакционно: когда памяти достаточно и конструктор завершился успешно, вы получаете объект, пригодный для использования. Если конструктор выбросил исключение, происходит откат изменений. В него входит вызов деструкторов полей объекта, которые успели сконструироваться, и освобождение памяти.</p>

<p>В C++ есть способ вручную сконструировать объект в ранее выделенной сырой области памяти — <strong>размещающий оператор</strong> <code>new</code>. Его синтаксис:</p>

<pre><code class="language-cpp">new (адрес) Класс(параметры конструктора)
</code></pre>

<p>Он вызывает конструктор класса <code>Класс</code> по адресу <code>адрес</code> и передаёт ему <code>параметры конструктора</code>. <code>Адрес</code> должен иметь выравнивание, нужное для типа <code>Класс</code>. Более подробно о выравнивании объектов в памяти вы узнаете в следующем спринте. Здесь затронем его на минимально необходимом уровне. Размещающий оператор <code>new</code> возвращает указатель типа <code>Класс*</code> на сконструированный объект.</p>

<p>Как только созданный так объект становится не нужен, его надо удалить. Для этого вызывают деструктор:</p>

<pre><code class="language-cpp">Obj* obj = ...;
...
obj.~Obj();
</code></pre>

<p>Когда создаёте объекты размещающим оператором <code>new</code>, всегда используйте явный вызов деструктора.</p>

<p>В следующем примере в области стека выделяется массив размера, достаточного для хранения объекта типа <code>Cat</code>. Затем размещающий оператор <code>new</code> конструирует в этом массиве экземпляр класса <code>Cat</code>. Перед выходом из <code>main</code> сконструированный вручную объект нужно разрушить, явно вызвав его деструктор:</p>

<pre><code class="language-cpp">int main() {
    alignas(Cat) char buf[sizeof(Cat)];
    Cat* cat = new (&amp;buf[0]) Cat(&quot;Luna&quot;s, 1);
    cat-&gt;SayHello();
    cat-&gt;~Cat();
}
</code></pre>

<p>Спецификатор <code>alignas</code> сообщает компилятору, что массив <code>buf</code> должен быть размещён в памяти с выравниванием, нужным типу <code>Cat</code>. Иначе возможно неопределённое поведение.</p>

<p>Запустим программу и увидим, что она работает идентично предыдущей:</p>

<pre><code>Hello from Luna
Meow, my name is Luna. I'm 1 year old.
Good bye from Luna
</code></pre>

<hr>

<p>Можно ли обернуть в <code>unique_ptr</code> указатель, который получен размещающим оператором <code>new</code>, как показано во фрагменте? Выберите один ответ.</p>

<pre><code class="language-cpp">int main() {
    alignas(Cat) char buf[sizeof(Cat)];

    unique_ptr&lt;Cat&gt; cat(new (&amp;buf[0]) Cat(&quot;Luna&quot;s, 1));
    cat-&gt;SayHello();
}
</code></pre>

<ul>
<li><p>Да</p></li>

<li><p>Нет</p></li>
</ul>

<p>Буфер, нужный для создания объекта, необязательно должен размещаться в области стека. Его можно выделить и динамически. Чтобы выделить сырой массив данных в куче, вызывают функцию <a href="https://en.cppreference.com/w/cpp/memory/new/operator_new"><code>operator new</code></a>. У неё есть несколько перегрузок. В нашем случае полезна эта:</p>

<pre><code class="language-cpp">void* operator new(std::size_t size);
</code></pre>

<p>Данную глобальную функцию может автоматически переопределить программист. Она выделяет <code>size</code> байт в динамической памяти и возвращает указатель на эту выделенную область. Функция возвращает указатель <code>void*</code>. Указатели такого типа могут ссылаться на данные произвольного типа.</p>

<p>Эта функция <code>operator new</code> выделяет память в куче по адресу, выровненному по умолчанию. В документации есть и другие её версии. С ними легко управлять выравниванием данных в динамической памяти.</p>

<p>Для возврата сырой памяти обратно в кучу служит парная функция <a href="https://en.cppreference.com/w/cpp/memory/new/operator_delete"><code>operator delete</code></a>. Версия функции, которую мы будем использовать, выглядит так:</p>

<pre><code class="language-cpp">void operator delete(void* ptr) noexcept;
</code></pre>

<p>Выделим сырую память, используя <code>operator new</code> перед конструированием объекта. После вызова деструктора удалим объект функцией <code>operator delete</code>:</p>

<pre><code class="language-cpp">int main() {
    void* buf = operator new (sizeof(Cat));
    Cat* cat = new (buf) Cat(&quot;Murka&quot;s, 4);
    cat-&gt;SayHello();
    cat-&gt;~Cat();
    operator delete (buf);
}
</code></pre>

<p>Убедимся в работоспособности программы:</p>

<pre><code>Hello from Murka
Meow, my name is Murka. I'm 4 year old.
Good bye from Murka
</code></pre>

<p>Именно этот подход с размещающим оператором <code>new</code> пригодится при разработке новой версии вектора. Но для начала решите задачу полегче: напишите упрощённую версию <code>std::optional</code>.</p>

</body>
</html>
