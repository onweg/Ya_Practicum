<!DOCTYPE html>
<html>
<head>
  <title>Проверьте себя</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta charset="utf-8">
<style>body{font-family:Helvetica,arial,sans-serif;font-size:14px;line-height:1.6;background-color:#fff;padding:30px;color:#333;max-width:1140px;margin:0 auto}body > :first-child{margin-top:0!important}body > :last-child{margin-bottom:0!important}a{color:#4183C4;text-decoration:none}a.absent{color:#c00}a.anchor{display:block;padding-left:30px;margin-left:-30px;cursor:pointer;position:absolute;top:0;left:0;bottom:0}h1,h2,h3,h4,h5,h6{margin:20px 0 10px;padding:0;font-weight:700;-webkit-font-smoothing:antialiased;cursor:text;position:relative}h2:first-child,h1:first-child,h1:first-child + h2,h3:first-child,h4:first-child,h5:first-child,h6:first-child{margin-top:0;padding-top:0}h1:hover a.anchor,h2:hover a.anchor,h3:hover a.anchor,h4:hover a.anchor,h5:hover a.anchor,h6:hover a.anchor{text-decoration:none}h1 tt,h1 code{font-size:inherit}h2 tt,h2 code{font-size:inherit}h3 tt,h3 code{font-size:inherit}h4 tt,h4 code{font-size:inherit}h5 tt,h5 code{font-size:inherit}h6 tt,h6 code{font-size:inherit}h1{font-size:28px;color:#000}h2{font-size:24px;border-bottom:1px solid #ccc;color:#000}h3{font-size:18px}h4{font-size:16px}h5{font-size:14px}h6{color:#777;font-size:14px}p,blockquote,ul,ol,dl,li,table,pre{margin:15px 0}hr {padding:0;margin-bottom:-8px;height:1px;border:none;background:black}body > h2:first-child{margin-top:0;padding-top:0}body > h1:first-child{margin-top:0;padding-top:0}body > h1:first-child + h2{margin-top:0;padding-top:0}body > h3:first-child,body > h4:first-child,body > h5:first-child,body > h6:first-child{margin-top:0;padding-top:0}a:first-child h1,a:first-child h2,a:first-child h3,a:first-child h4,a:first-child h5,a:first-child h6{margin-top:0;padding-top:0}h1 p,h2 p,h3 p,h4 p,h5 p,h6 p{margin-top:0}li p.first{display:inline-block}ul,ol{padding-left:30px}ul :first-child,ol :first-child{margin-top:0}ul :last-child,ol :last-child{margin-bottom:0}dl{padding:0}dl dt{font-size:14px;font-weight:700;font-style:italic;padding:0;margin:15px 0 5px}dl dt:first-child{padding:0}dl dt > :first-child{margin-top:0}dl dt > :last-child{margin-bottom:0}dl dd{margin:0 0 15px;padding:0 15px}dl dd > :first-child{margin-top:0}dl dd > :last-child{margin-bottom:0}blockquote{border-left:4px solid #ddd;padding:0 15px;color:#777}blockquote > :first-child{margin-top:0}blockquote > :last-child{margin-bottom:0}table{padding:0}table tr{border-top:1px solid #ccc;background-color:#fff;margin:0;padding:0}table tr:nth-child(2n){background-color:#f8f8f8}table tr th{font-weight:700;border:1px solid #ccc;text-align:left;margin:0;padding:6px 13px}table tr td{border:1px solid #ccc;text-align:left;margin:0;padding:6px 13px}table tr th :first-child,table tr td :first-child{margin-top:0}table tr th :last-child,table tr td :last-child{margin-bottom:0}img{max-width:100%;display:block}span.frame{display:block;overflow:hidden}span.frame > span{border:1px solid #ddd;display:block;float:left;overflow:hidden;margin:13px 0 0;padding:7px;width:auto}span.frame span img{display:block;float:left}span.frame span span{clear:both;color:#333;display:block;padding:5px 0 0}span.align-center{display:block;overflow:hidden;clear:both}span.align-center > span{display:block;overflow:hidden;margin:13px auto 0;text-align:center}span.align-center span img{margin:0 auto;text-align:center}span.align-right{display:block;overflow:hidden;clear:both}span.align-right > span{display:block;overflow:hidden;margin:13px 0 0;text-align:right}span.align-right span img{margin:0;text-align:right}span.float-left{display:block;margin-right:13px;overflow:hidden;float:left}span.float-left span{margin:13px 0 0}span.float-right{display:block;margin-left:13px;overflow:hidden;float:right}span.float-right > span{display:block;overflow:hidden;margin:13px auto 0;text-align:right}code,tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px}pre code{margin:0;padding:0;white-space:pre;border:none;background:transparent}.highlight pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre code,pre tt{background-color:transparent;border:none}.slasher{color:#000000}</style></head>
<body>

<h1>Проверьте себя</h1>

<p>Мы приближаемся к концу темы. Впереди только финальное задание. Проверьте, как вы усвоили понятие сложности.</p>

<hr>

<p>Почему обычно оценивают худший случай? Отметьте несколько вариантов.</p>

<ul>
<li><p>Так проще.</p></li>

<li><p>Чтобы сделать программу устойчивой к атакам.</p></li>

<li><p>Между худшим и лучшим обычно нет никакой разницы.</p></li>

<li><p>Худший часто совпадает со средним.</p></li>

<li><p>Худший случай оценивают пессимисты, лучший — оптимисты. Этот курс составляли пессимисты, поэтому в нём рассматриваются худшие случаи.</p></li>
</ul>

<hr>

<p>О каком алгоритме говорят, что он работает за амортизированное O(1)?</p>

<ul>
<li><p>Алгоритм, который работает ограниченное время, вне зависимости от входных данных.</p></li>

<li><p>Алгоритм, который иногда работает быстро, редко медленно, и при усреднении большого количества запусков получается константа.</p></li>

<li><p>Алгоритм, разработанный достаточно давно и приобретший специфический аромат.</p></li>
</ul>

<hr>

<p>Ядро процессора выполняет миллиард операций в секунду. Какой размер вектора сможет обработать такой алгоритм за секунду или меньше?</p>

<pre><code class="language-cpp">void FindDuplicates(const vector&lt;int&gt;&amp; v) {
    for (size_t i = 0; i &lt; v.size(); ++i) {
        for (size_t j = 0; j &lt; v.size(); ++j) {
            if (v[i] == v[j] &amp;&amp; i &lt; j) {
                cout &lt;&lt; &quot;Найден дубликат &quot;s &lt;&lt; v[i] &lt;&lt; endl;
            }
        }
    }
}
</code></pre>

<p>Известно, что в векторе не более десяти дубликатов. Отметьте несколько вариантов:</p>

<ul>
<li><p>100</p></li>

<li><p>1 000</p></li>

<li><p>10 000</p></li>

<li><p>100 000</p></li>

<li><p>1 000 000</p></li>
</ul>

<hr>

<p>Отметьте верные утверждения.</p>

<ul>
<li><p>Алгоритм с меньшей сложностью всегда работает быстрее алгоритма с большей сложностью. По крайней мере в худшем случае.</p></li>

<li><p>Алгоритм, решающий задачу с наилучшей сложностью, будет быстрым.</p></li>

<li><p>Алгоритм с худшей сложностью бывает быстрее алгоритма с лучшей сложностью даже при больших входных данных.</p></li>

<li><p>Гарантировано, что в худшем случае и при достаточно больших данных алгоритм, имеющий меньшую сложность, будет работать быстрее алгоритма, имеющего большую сложность.</p></li>
</ul>

<hr>

<p>Установите соответствие между алгоритмом и сложностью.</p>

<ul>
<li><p>O(A^N)</p></li>

<li><p>O(1)</p></li>

<li><p>O(N)</p></li>

<li><p>амортизированная O(1)</p></li>

<li><p>O(\log N)</p></li>

<li><p>O(N\log N)</p></li>
</ul>

<hr>

<p>Последний вопрос.</p>

<p>Это будет непросто, но попробуйте оценить сложность функции <code>F</code>:</p>

<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;random&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

string RandString(int len) {
    static mt19937 engine;

    // строка длины len из символов 'A'
    string s(len, 'A');
    for (int i = 0; i &lt; len / 2; ++i) {
        uniform_int_distribution&lt;int&gt; dist(0, i - 1);
        s[dist(engine)] = 'B';
    }

    return s;
}

void F(int n, int m) {
    vector&lt;int&gt; v1;
    vector&lt;string&gt; v2;

    for (int i = 0; i &lt; m; ++i) {
        v1.push_back(rand() % 100);
    }

    for (int i = 0; i &lt; n; ++i) {
        v2.push_back(RandString(i));
    }

    sort(v2.begin(), v2.end());

    for (int r : v1) {
        for (int j = 0; j &lt; r * 2; ++j) {
            string s = RandString(n);
            upper_bound(v2.begin(), v2.end(), s);
        }
    }
}
</code></pre>

<ul>
<li><p>O(m+n)</p></li>

<li><p>O(mn)</p></li>

<li><p>O(mn\log n)</p></li>

<li><p>O(mn\log n + n^2\log n)</p></li>

<li><p>O(m+n^2\log n)</p></li>

<li><p>O(mn + n^2)</p></li>
</ul>

<p>Решить можно так.</p>

<p>Первый цикл имеет сложность O(m), второй — O(n^2), так как он делает n итераций, а худшая сложность итерации сама равна n. Сортировка делает O(n\log n) сравнений, каждое из которых имеет худшую сложность O(n). По правилу умножения вся сортировка потребует O(n^2\log n) операций в худшем случае.</p>

<p>Цикл, вложенный в третий, делает не более C итераций, а именно не более 200, поэтому его можно не учитывать вовсе. По документации <code>upper_bound</code> делает O(\log n) сравнений, но каждое сравнение строк само занимает время O(n). Таким образом, по правилу умножения тело третьего цикла имеет сложность O(n\log n). Умножаем на количество итераций, получаем сложность третьего цикла O(mn\log n).</p>

<p>Теперь суммируем три цикла: O(m) будет поглощено третьим циклом, но сравнить O(n^2\log n) и O(mn\log n) нельзя, так что ответом будет их сумма.</p>

</body>
</html>
